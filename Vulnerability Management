vulnerability management 에 대한 스터디 결과 (2020.4.15)

vulnerability mgmt(취약점 관리)는
1) patch mgmt와 공통점 있음
: patch는 기능 추가 또는 버그수정 보다는 취약점개선에 주 목적
: patch로서 모든 취약점이 해결되진 않는다.
2) configuration mgmt(환경설정 관리)와 공통점
: 잘못된 환경설정은 취약점 약화

클라우드환경에서-> 취약점은 다양한 계층(layers)에서 발생한다.

전통적 취약점관리방식
1) Discover : 보안업데이트 또는 환경설정변화가 가능한지
2) Prioritize: 보안사고 위험에 기반하여 어떤 업데이트가 우선 실행해야하는지
3) Test : 테스트환경에서 업데이트가 실행되는지
4) Schedule: 스케쥴링 업데이트 
5) Deploy: 배포
6) Verify: 확인

Cloud Offerings and Infrastructure as Code
: 환경 정의를 part of the code 가능하게 한다.
: 새 환경과 새 코드를 동시에 tested together 가능하게 한다.
Continuous Integration, Continuous Delivery
: 작은 변동사항들을 모든 각각의 iteration에 반영 가능하게 한다.
Microservice architecture
: 서비스들을 decouple시켜줘, 특히 container-based microservice환경에서는
더욱 그렇다. 
이러한 것들은 higher availability 를 향해 swing balance한다.
overall availability of the system를 낮추지 않으면서 더 proactive할 수 있다

새로운 vulnerability mgmt의 특징:
1) Automatically Pull: 가능한 보안업데이트를 일반적 개발 노력의 일부분으로 끌어들인다
2) Test: 보안업데이트를 일반적 application test흐름의 일부로서 테스트한다.
3) Deploy : 자동으로 new production environment 를 생성하는 new version을 deploy
4) Discover: test또는 production 환경에서 발견되는 추가적 취약점을 발견하고 다룬다.

Vulnerable Areas(취약 영역)
1. Data Access
: how to grant access to the data 하는 것은 대부분 customer의 책임 부분

2. Application
: Saas 에서는 provider의 책임인 경우이나, 보안관련 configuration item 에서 customer책임인 경우도 있다.
: 예를 들어 web email시스템 이용시, reasonable configuration 셋팅하는 것 중요(two-factor authentication
또는 malware scanning 과 같은)
: SaaS가 아닌 경우에서는 application code를 writing할 것인데(virtual machine이나 PaaS나 서버리스에 hosted)
필연적으로 bug를 가지게 되어 보안에 영향준다.
또한, own 코드 외에도 frameworks나 libraries, 써드파티로부터 제공받은 코드 사용하며 취약점 가질 수 있다.
이처럼 inherited codes는 공격에 노출될 수 있다.

3. Middleware
보안 사고 유발하는 미들웨어/플랫폼 환경설정(configuration) 이슈
- 웹서버에서 우연히 패스워드파일 allow to view되도록 configured
- database에 대한 authentication이 올바르지 않은 방식으로 configured
- Java application 서버가 debug output을 제공하도록 configure되어서 버그침투시 패스워드를 노출

4. Network
2 main tasks: 네트워크 요소 (그 자체) 관리 / 어떤 네트워크 커뮤니케이션이 allowed되었는지 관리
vulnerability scanner가 firewall 에 poke hole을 감수하더라도 allowed to scan every component 해야된다.

5. Agentless Scanners and Configuration Management
네트워크 vulnerability scanner가 문을 두드리면 agenetless scanners와 configuration mgmt systems가 집안에
들어가 뒤진다. 
agentless scanner는 network vulnerability scanner가 찾을 수 없는 취약점을 찾을 수 있다.
	

Finding and Fixing Vulnerabilities

NVS (Network Vulnerability Scanners)
NVS: 소프트웨어 요소를 보지않는다. 단지 make network request & try to fiure out what's listening & check for vulnerable versions of server applications
예로, NVS는 insecure connections를 determine 할 수 있다.
그러나 NVS는 다른 웹애플리케이션 이나 그 네트워크 주소에 served up된 REST APIs를 알 수 없다.
놀랍게도 NVS는 전체인터넷 또는 전체클라우드를 스캔할 수 없다. 반면, 당신의 책임소재를 알 수 있다.
따라서 NVS사용하려면 network address가 필수 있어야됨. (혹시나 놓친 address가 있다면 취약점에 노출되는 것임)

DAST (Dynamic Application Scanners ) 동적 애플리케이션 스캐너

- Network vulnerability scanners가 Network Address에 against해서 run하는 것에 비해
  dynamic web applicaiton vulnerability scanners는 구동중인 웹애플리케이션 또는 REST API의 특정 URL에 against하여 run
- DAST는 크로스사이트 스크립핑(XSS) 이나 SQL 인젝션과 같은 이슈를 찾아낼 수 있다.
- 이러한 스캐너는 주로 애플리케이션 크리덴셜을 필요로 한다.

- DAST에서 발견할 수 있는 몇몇 vulnerabilities는 web application firewalls에 의해 block될 수는 있다.
  따라서 간과할 수 있는데, 만약 시스템이 적절하지 않게 configured되어있다면 공격자들은 WAFS를 뛰어넘고 애플리케이션을 directly 공격할 수 있다.

- Dynamic Scanners는 보통은 스케쥴에 따라 자동 실행되며 , 애플리케이션에 변화가 생길 경우 D.S는 그 결과를 issue tracking system에 feed한다

SAST (Static Application Scanners) 정적 애플리케이션 스캐너

- DAST가 구동중 애플리케이션을 look하는 것에 비해, SAST는 look directly at the Code You've written.
  따라서 SAST는 즉각적 피드백을 주는 데 있어, new code가 실행될 때 part of the deployment pipeline의 일부로서 구동하는 데 good candidate이다
  SAST는 보안관련 에러(예를 들어 사람이 발견하기 힘든 memory leaks 또는 off-by-one 에러)를 잡아낼 수 있다.
  SAST가 소스코드를 분석하기 때문에 , 원래 사용하는 언어 위해 designed된 스캐너를 사용해야 한다.
  다행히도 스캐너들은 일반적 언어 wide range로 개발이 되어 있고 서비스로 제공된다. (예를 들어 미국 국토안보부에서 제공하는 SWAMP)
  SAST의 가장 큰 문제는 false positive rate가 높다는 것. -> 개발자들에게 있어서 security fatigue를 유발시킨다
  deployment pipeline의 일부로서 static code를 deploy할 경우, 사용 중인 언어와 맞아야 작동이 된다는 사실과 mask false positives하기 쉽단 사실을 명심할 것

SCA (Software Composition Analysis Scanners)

- 거의 틀림없이, SAST의 연장선으로서 SCA는:  code you've written보다는 오픈소스 dependencies를 우선적으로 본다(look)
- 요즈음 대부분의 애플리케이션들은 frameworks나 libraries와 같은 오픈소스 components를 많이 쓰는데 여기 내재된 취약점들이 큰 문제를 일으킬 수 있다.
- SCA tools는 사용 중인 오픈소스 components&versions를 자동적으로 식별하고, 알려진 취약점에 대해 cross-reference를 한다.
- 때로는 자동적으로 newer versions를 사용하는 코드를 자동으로 propose한다.
- 또한, some products는 취약점 관리에 더해, 오픈소스 요소가 사용하는 licenses를 들여다본다. (unfavorable licensing을 사용하지 않는단 점을 ensure하기 위해)
- SCA tools는 지난 수년간 higher-impact vulnerabilities를 완화시키는 데 도움을 줬다.
  (예를 들어 Apache Struts와 Spring Development Framework에서 발견할 수 있듯이)

IAST (Interactive Application Scanners)  대화식 애플리케이션 스캐너
- Interactive application Secuiry testing(IAST) tools는 SAST와 DAST 둘 다의 역할을 조금씩 한다.
- IAST는 코드를 보고, 코드가 run할 떄 watch it from the inside 한다.
  애플리케이션 코드와 동시에(alongside) IAST 코드를 로딩함으로써 하는데, 애플리케이션이 functional test, dynamic scanner 또는 실사용자에 의해 실행이 되는지
  to watch하기 위함.
- IAST솔루션은 SAST나 DAST에 비해 문제를 찾고 false positives를 제거하는데 있어 더 효과적이다.
- SAST와 마찬가지로 사용 중인 특정 언어와 런타임이 supported되어야 한다. 
- IAST는 애플리케이션과 같이 구동(run along with)하기 때문에 프로덕션 환경에서는 성능저하를 일으킬 수 있는데 요즈음 애플리케이션 아키텍쳐에서는
  horizontal scaling으로서 다소 완화시킬 수는 있다.

RASP (Runtime Application Self-Production Scanners) 런타임 애플리케이션 자가프로덕션 스캐너
- RASP가 앞서 언급한 스캐너와 비슷하게 들릴진 몰라도, RASP는 scanning technology의 영역은 아니다.
  애플리케이션 코드와 동시에 deploy되는 agent라는 점에서는 IAST와 유사하게 작동한다. 그러나 RASP는 단순 취약점 스캔이 아닌 "block attacks"하기 위해
  고안된 툴이다. (어떤 products는 RASP와 IAST 역할을 동시에 한다.)
- IAST에서와 마찬가지로 production환경에서는 코드가 더 많이 running됨으로써 성능저하가 발생할 수 있다.
- RASP솔루션은 WAF에서와 몇몇은 같은 protection을 제공한다.(둘 다 block attacks하기 때문). 이러한 이유로 RASP와 WAF솔루션 둘 다 chapter6에 소개.

Manual Code Reviews (수작업 코드 리뷰)
- MCR은 고비용에 많은시간소요 할 수 있음. 그러나 many types of 취약점을 찾는데 있어서 application testing tools보다 낫다
- 특정 piece of code 가 왜 취약점을 갖는지에 대해 설명하는 다른 한 사람을 확보하는 것이 자동화툴의 결과를 이해하려 노력하는 것보다  더 효과적일 수 있다.
- 코드 리뷰는 많은 high-security 환경에서 정석적인 행동이다. 다른 환경에서는 단지 code with specific significance to securiy 부분을 위해서만 사용됨.
  (예를 들어, encrytion 또는 access control을 수행하는 부분)
 
Penetration Tests
- Pentest는 someone you've engaged에 의해 , 당신의 시스템에 허가되지 않은 접근을 실행하여 취약점이 어디에 있는지를 당신에게 알려줌
- 앞에서 언급되었던 automated scans는 Pentest가 아니란 점을 알아야 함.(Pentester의 스타팅포인트로서 사용될 순 있다더라도)
- 독립된 써드파티로부터의 Pentest는 PCI DSS, FedRAMP moderate/high standards에 의해 요구됨
- 전문용어에 대해서는 이견이 있는데, 일반적으로 white box pentesting에서는 펜테스터에게 design of the system을 제공하지만 passwords나 API keys와 같은
비밀정보는 제공하지 않음.
- black box pentesting에서는 어떠한 정보도 제공하지 않고 펜테스터를 지정
- gray box pentesting: 제한적 정보만..
- w.box, g.box pentesting이 b.box pentesting보다 spend less time on reconnaisance & more time on finding actual vulnerabilites 따라서 더 effective
- pentestrer가 일반적으로 1 or 2 가지 ways into the system 찾을 수 있다. 그러나 모두 찾을 순 없다.
- 펜테스팅의 결과 negative 또는 minimal findings가 어느정도 당신에게 confidence를 줄 순 있으나, 만약 major findings가 있어서 특정 취약점을 고친다고 하면 
수긍할만한 결과가 나올 때까지 retesting 해야 한다. 
- Pentesting은 일반적으로 고비용이므로 펜테스터들의 결과물이 automated scans이 할 수 있는 것들과 같다면 돈낭비다.
- pentesting은 주로 거의 release 직전 단계에서 행해짐.
- automated scans가 주로 잠재적 취약점을 발견한다면, pentesting은 (올바르게 행해진다면) 실재하는 성공적인 취약점을 발견할 수 있다.
- 대부분의 클라우드서비스제공업자들은 당신이 pentest를 행하기 전 사전승인을 요한다.

User Reports(사용자 보고)
- 유저로부터 또는 취약점 제보 프로그램으로부터의 보고받을 수 있다.
- well defined process가 있어야 한다(보고의 진실성 판단, 수정, 유저와의 소통 위한)
- end users, public relations, legal issues를 다룰 수 있는 전문가를 두면서까지 reponse를 효과적으로 해야됨 (안그러면 reputaion 에 피해 입음)

앞서 언급한 대부분의 tools는 클라우드 환경에도 융화될 수 있다.
대부분의 클라우드사업자들은 벤더들과 파트너십을 갖거나 그들 소유의 취약점 관리 툴을 가지고 있다.
아주 많은 툴들이 하나 이상의 영역을 가지므로, 일찍이 언급된 영역으로 categorize하긴 힘들다.
클라우드취약점 및 환경설정 관리 영역에서 대표적인 몇몇 solutions 리스트를 종합하였는데
이 중 몇가지 툴은 앞선 챕터에서와 중첩되는 내용들.
 
Amazon Inspector
: agent-based scanner로서 , missing patches 또는 Linux나 Windows 시스템 상의 잘못된 환결설정을 스캔할 수 있다.


Agent-based vs Agentless
Agent vs Agentless

앞서 이야기한 것처럼 Agent-based system은 점검, 모니터링 하는 소프트웨어 툴을 설치하여 시스템을 모니터링하는 것을 뜻한다. 
이러한 Agent는 dissolvable과 같이 임시적으로 설치되고 다시 삭제되는 형태나 permanent처럼 영구적으로 사용될 수 있다. 
Agent-based system은 업데이트, configuration이 자동으로 점검/적용되며 
agentless system은 일반적으로 관리자가 수동으로 발견된 이슈를 처리해야한다. 
Agent-based가 더 많은 기능을 제공하고 있지만 Agentless가 더 보안적으로 특수하며 이는 malware등에 감염되기가 어렵기 때문이다. 



  




